================================================================================
DIAGN√ìSTICO 03: COMANDOS DE COBERTURA ENCONTRADOS
================================================================================

‚úì 282 linhas encontradas com keywords:

[.coveragerc]
  Linha 1: # .coveragerc - Configura√ß√£o de coverage para RC Gestor
  Linha 5: # Arquivo de dados do coverage (sempre na raiz do projeto)
  Linha 6: data_file = .coverage
  Linha 21: # Habilitar branch coverage para m√©tricas mais completas
  Linha 31: # Omitir arquivos n√£o relevantes para coverage de produto

[.github\workflows\ci.yml]
  Linha 27:       - name: Run tests with coverage
  Linha 28:         run: python -m pytest --cov=src --cov-report=term-missing --cov-fail-under=25 -v
  Linha 30:       - name: Upload pytest artifacts
  Linha 34:           name: pytest-report
  Linha 35:           path: .pytest_cache

[.github\workflows\release.yml]
  Linha 24:           pip install -U pyinstaller pytest
  Linha 27:         run: pytest -q
  Linha 83:             - ‚úì Testes passaram (pytest)

[pyproject.toml]
  Linha 22: "tests/unit/core/test_auth_bootstrap_microfase.py" = ["E741", "F401"]
  Linha 23: "tests/unit/modules/passwords/test_passwords_screen_ui.py" = ["F401", "F811", "F841"]
  Linha 24: "tests/unit/modules/lixeira/test_lixeira_service.py" = ["E731"]
  Linha 27: "tests/unit/infra/test_archives.py" = ["N802"]  # Test name matches ZIP64 standard
  Linha 28: "tests/unit/adapters/test_adapters_supabase_storage_fase37.py" = ["N806"]  # Mock naming convention
  Linha 29: "tests/unit/modules/clientes/forms/test_prepare_round12.py" = ["N806"]  # Mock naming convention
  Linha 50:     ".pytest_cache",
  Linha 118: exclude = ["tests", "docs", "reports", "build", "dist", ".venv", "venv", ".pytest_cache", ".ruff_cache", "__pycache__"]

[pytest.ini]
  Linha 1: [pytest]
  Linha 4: # MODO R√ÅPIDO POR PADR√ÉO (sem coverage)
  Linha 5: # Para rodar COBERTURA GLOBAL completa: pytest -c pytest_cov.ini
  Linha 6: # Gera relat√≥rios em htmlcov/ e reports/coverage.json

[pytest_cov.ini]
  Linha 2: # pytest_cov.ini - Configura√ß√£o para COBERTURA GLOBAL do RC Gestor
  Linha 5: #   pytest -c pytest_cov.ini
  Linha 13: #   - JSON: reports/coverage.json
  Linha 16: [pytest]
  Linha 19: # Configura√ß√£o completa para coverage global
  Linha 24:     --cov-config=.coveragerc
  Linha 25:     --cov=src
  Linha 26:     --cov=adapters
  Linha 27:     --cov=infra
  Linha 28:     --cov=data
  Linha 29:     --cov=security
  Linha 30:     --cov-report=term-missing:skip-covered
  Linha 31:     --cov-report=html:htmlcov
  Linha 32:     --cov-report=json:reports/coverage.json
  Linha 33:     --cov-report=xml:reports/coverage.xml

[scripts\audit_legacy_usage.py]
  Linha 20:     ".pytest_cache",

[scripts\audit_repo.py]
  Linha 26:     ".pytest_cache",
  Linha 131:     "pytest",

[scripts\codex_qa_full.ps1]
  Linha 63: # (7) Pytest modo r√°pido (sem cobertura) + smoke (se quiser primeiro)
  Linha 64: Run-Step "pytest_smoke" { python -m pytest --smoke -c pytest.ini -ra --continue-on-collection-errors }
  Linha 66: # (8) Pytest FULL + COBERTURA GLOBAL (usa pytest_cov.ini do repo)
  Linha 67: # Obs: seu pytest_cov.ini j√° define --cov-report html/json/xml e --cov-config.
  Linha 68: Run-Step "pytest_cov_full" { python -m pytest -c pytest_cov.ini -ra --continue-on-collection-errors }
  Linha 70: # (9) Ranking de cobertura (usa reports/coverage.json como fallback)
  Linha 71: Run-Step "coverage_ranking" { python .\scripts\coverage_ranking.py }
  Linha 82: Write-Host "Cobertura (se gerou): htmlcov\index.html e reports\coverage.json"

[scripts\coverage_clean.ps1]
  Linha 1: # coverage_clean.ps1
  Linha 2: # Remove todos os artefatos de coverage gerados anteriormente
  Linha 6: Remove-Item -Recurse -Force ".\reports\coverage"
  Linha 8: Remove-Item -Force ".\coverage.json"
  Linha 9: Get-ChildItem -Force ".\.coverage*" | Remove-Item -Force
  Linha 11: Write-Host "OK: coverage artifacts removidos (reports/coverage, htmlcov, coverage.json, .coverage*)"

[scripts\coverage_gaps.py]
  Linha 4: Analisa reports/coverage.json e lista os 10 arquivos com pior cobertura.
  Linha 9:     python scripts/coverage_gaps.py
  Linha 21: COVERAGE_JSON = PROJECT_ROOT / "reports" / "coverage.json"
  Linha 27: def load_coverage_data() -> dict:
  Linha 28:     """Carrega dados do coverage.json."""
  Linha 29:     if not COVERAGE_JSON.exists():
  Linha 30:         print(f"[ERRO] Arquivo n√£o encontrado: {COVERAGE_JSON}")
  Linha 31:         print("Execute primeiro: python -m pytest -c pytest_cov.ini")
  Linha 34:     with open(COVERAGE_JSON, encoding="utf-8") as f:
  Linha 93:     data = load_coverage_data()
  Linha 132:     print("  - reports/coverage.json")
  Linha 133:     print("  - reports/coverage.xml")

[scripts\coverage_global.cmd]
  Linha 2: REM coverage_global.cmd
  Linha 8: set "COVERAGE_FILE="
  Linha 10: py -m pytest -q -c pytest.ini --cov-report=term-missing --cov-report=html:htmlcov --cov-report=json:coverage.json
  Linha 12: echo OK: htmlcov\index.html e coverage.json na raiz

[scripts\coverage_global.ps1]
  Linha 1: # coverage_global.ps1
  Linha 8: Remove-Item Env:COVERAGE_FILE -ErrorAction SilentlyContinue
  Linha 11: Remove-Item -Recurse -Force ".\reports\coverage" -ErrorAction SilentlyContinue
  Linha 13: Remove-Item -Force ".\coverage.json" -ErrorAction SilentlyContinue
  Linha 14: Get-ChildItem -Force ".\.coverage*" -ErrorAction SilentlyContinue | Remove-Item -Force
  Linha 17: py -m pytest -q -c pytest.ini `
  Linha 18:   --cov-report=term-missing `
  Linha 19:   --cov-report=html:htmlcov `
  Linha 20:   --cov-report=json:coverage.json
  Linha 23: Write-Host "OK: gerado htmlcov\index.html e coverage.json na raiz."

[scripts\coverage_inspecao.py]
  Linha 10: COV_JSON = Path("reports/coverage.json")
  Linha 11: OUT_MD = Path("reports/inspecao/coverage_inspecao.md")
  Linha 12: OUT_TXT = Path("reports/inspecao/coverage_inspecao.txt")
  Linha 25:         # F√≥rmula padr√£o de statements (aproxima o que o coverage usa em totals).
  Linha 95:             # ignore venv/pytest cache
  Linha 108:             f"ERRO: {COV_JSON} n√£o encontrado. N√£o rode coverage de novo; gere o arquivo uma vez e re-use."
  Linha 140:     # Arquivos .py no repo que n√£o aparecem no coverage.json
  Linha 178:         "== Arquivos .py existentes que N√ÉO aparecem no coverage.json (poss√≠vel: nunca importados/executados) =="
  Linha 190:     print(f"[OK] Lista completos n√£o-no-coverage: {OUT_TXT}")

[scripts\coverage_ranking.py]
  Linha 4: L√™ coverage.json e gera ranking de arquivos com:
  Linha 22: def load_coverage(coverage_path: Path) -> dict:
  Linha 23:     """Carrega o arquivo coverage.json"""
  Linha 24:     # Tentar primeiro em reports/coverage.json
  Linha 25:     if not coverage_path.exists():
  Linha 26:         alternative_path = Path("reports/coverage.json")
  Linha 28:             coverage_path = alternative_path
  Linha 29:             print(f"üìä Analisando cobertura: {coverage_path}")
  Linha 31:             print(f"‚ùå Arquivo n√£o encontrado: {coverage_path}")
  Linha 32:             print("   Rode: pytest -c pytest_cov.ini")
  Linha 36:         with open(coverage_path, "r", encoding="utf-8") as f:
  Linha 43: def analyze_files(coverage_data: dict) -> list[dict]:
  Linha 45:     Analisa os arquivos do coverage e retorna lista de candidatos.
  Linha 52:     files = coverage_data.get("files", {})
  Linha 149:     # Localizar coverage.json
  Linha 151:     coverage_path = project_root / "coverage.json"
  Linha 153:     print(f"üìä Analisando cobertura: {coverage_path}")
  Linha 156:     coverage_data = load_coverage(coverage_path)
  Linha 157:     candidates = analyze_files(coverage_data)
  Linha 172:     print(f"üìÅ Arquivo de cobertura: {coverage_path.relative_to(project_root)}")

[scripts\doctor_tests.ps1]
  Linha 1: Write-Host "=== RC Doctor: repo/venv/pytest/coverage ==="
  Linha 13: Write-Host "`n[Pytest]"
  Linha 14: python -m pytest --version
  Linha 17: $vars = @('PYTEST_ADDOPTS','PYTHONPATH','RC_TESTING','RC_RUN_GUI_TESTS','COVERAGE_FILE','COVERAGE_RCFILE')
  Linha 24: Write-Host (".pytest_cache exists? " + (Test-Path .\.pytest_cache))
  Linha 25: if (Test-Path .\.pytest_cache) {
  Linha 26:   $count = (Get-ChildItem .\.pytest_cache -Recurse -ErrorAction SilentlyContinue | Measure-Object).Count
  Linha 27:   Write-Host ("pytest cache entries=" + $count)
  Linha 30: Write-Host "`n[Coverage files]"
  Linha 31: Write-Host (".coverage exists? " + (Test-Path .\.coverage))
  Linha 32: if (Test-Path .\.coverage) {
  Linha 33:   $size = (Get-Item .\.coverage).Length
  Linha 34:   Write-Host (".coverage bytes=" + $size)

[scripts\pick_coverage_batch.py]
  Linha 3: Uso: python scripts/pick_coverage_batch.py <batch_number> [min_stmts] [max_stmts]
  Linha 4: Exemplo: python scripts/pick_coverage_batch.py 3
  Linha 5:          python scripts/pick_coverage_batch.py 4 50 100
  Linha 31:         print("Uso: python scripts/pick_coverage_batch.py <batch_number> [min_stmts] [max_stmts]")
  Linha 41:     cov_json = Path("reports/coverage.json")
  Linha 125:     cov_json = Path("reports/coverage.json")

[scripts\run_smoke.py]
  Linha 4: L√™ nodeids de scripts/suites/smoke_nodeids.txt e executa pytest.
  Linha 55:         "pytest",
  Linha 70:     # Executar pytest
  Linha 71:     print(f"\n[smoke] Executando pytest com {len(nodeids)} nodeids...")

[tools\diagnose_clientes_env_and_coverage.py]
  Linha 4: Gera 5 arquivos de diagn√≥stico para an√°lise de ambiente, coverage e testes.
  Linha 199:                         "python.testing.pytestEnabled",
  Linha 200:                         "python.testing.pytestArgs",
  Linha 269: # ===== DIAGN√ìSTICO 3: TRACE COVERAGE =====
  Linha 272: def diagnose_trace_coverage() -> None:
  Linha 273:     """Executa tools/trace_coverage_clientes.py e captura output."""
  Linha 274:     print("üîç [3/5] Executando trace coverage...")
  Linha 279:     trace_script = PROJECT_ROOT / "tools" / "trace_coverage_clientes.py"
  Linha 283:         warning += "N√£o √© poss√≠vel executar trace coverage.\n"
  Linha 320:         error_content = "‚ùå TIMEOUT: Trace coverage excedeu 5 minutos\n"
  Linha 326:         error_content = f"‚ùå ERRO ao executar trace coverage:\n\n{traceback.format_exc()}"
  Linha 332: # ===== DIAGN√ìSTICO 4: PYTEST COLLECT =====
  Linha 335: def diagnose_pytest_collect() -> None:
  Linha 336:     """Executa pytest --collect-only e captura output."""
  Linha 337:     print("üîç [4/5] Executando pytest --collect-only...")
  Linha 339:     output_file = DIAGNOSTICS_DIR / "04_pytest_collect_only.txt"
  Linha 342:         # Executa pytest --collect-only
  Linha 344:             [sys.executable, "-m", "pytest", "tests", "-q", "--collect-only"],
  Linha 367:         print(f"   {status} Pytest collect executado (returncode={result.returncode})")
  Linha 371:         error_content = "‚ùå TIMEOUT: pytest --collect-only excedeu 1 minuto\n"
  Linha 376:         error_content = f"‚ùå ERRO ao executar pytest --collect-only:\n\n{traceback.format_exc()}"
  Linha 381: # ===== DIAGN√ìSTICO 5: PYTEST COM SKIP REASONS =====
  Linha 384: def diagnose_pytest_run_with_skips() -> None:
  Linha 385:     """Executa pytest -rs e captura output com motivos de skip."""
  Linha 386:     print("üîç [5/5] Executando pytest com skip reasons (-rs)...")
  Linha 388:     output_file = DIAGNOSTICS_DIR / "05_pytest_run_with_skips.txt"
  Linha 391:         # Executa pytest -rs
  Linha 393:             [sys.executable, "-m", "pytest", "tests/modules/clientes", "-q", "-rs"],
  Linha 416:         print(f"   {status} Pytest executado (returncode={result.returncode})")
  Linha 420:         error_content = "‚ùå TIMEOUT: pytest excedeu 3 minutos\n"
  Linha 425:         error_content = f"‚ùå ERRO ao executar pytest:\n\n{traceback.format_exc()}"
  Linha 447:     diagnose_trace_coverage()
  Linha 448:     diagnose_pytest_collect()
  Linha 449:     diagnose_pytest_run_with_skips()
  Linha 465:         "04_pytest_collect_only.txt",
  Linha 466:         "05_pytest_run_with_skips.txt",

[tools\trace_coverage_clientes.py]
  Linha 2: """Script de coverage usando stdlib trace para testes do m√≥dulo Clientes.
  Linha 5: gerar relat√≥rios de cobertura sem instalar pytest-cov ou coverage.py.
  Linha 13: 4. Verificar relat√≥rios em coverage/trace/
  Linha 64: COVERAGE_DIR = PROJECT_ROOT / "coverage" / "trace"
  Linha 76: TEST_PATH = "tests/modules/clientes/"
  Linha 89:     # Cria diret√≥rio de coverage se n√£o existir
  Linha 90:     COVERAGE_DIR.mkdir(parents=True, exist_ok=True)
  Linha 92:     print(f"[DIR] Diretorio de coverage: {COVERAGE_DIR.relative_to(PROJECT_ROOT)}")
  Linha 127:     """Executa pytest com trace ativo.
  Linha 133:         Exit code do pytest (0 = sucesso, >0 = falhas).
  Linha 136:         import pytest
  Linha 138:         print("[ERROR] pytest nao encontrado. Instale com: pip install pytest")
  Linha 145:     # Executa pytest programaticamente
  Linha 146:     # Nota: pytest.main() retorna exit code (n√£o levanta SystemExit)
  Linha 148:         pytest.main,
  Linha 165: def generate_coverage_report(tracer: trace_module.Trace) -> None:
  Linha 177:     # Escreve relat√≥rios anotados em coverage/trace/
  Linha 183:         coverdir=str(COVERAGE_DIR),
  Linha 188:     print(f"[SAVE] Relatorios salvos em: {COVERAGE_DIR.relative_to(PROJECT_ROOT)}")
  Linha 202:     cover_files = sorted(COVERAGE_DIR.glob("**/*.cover"))
  Linha 236:     print("[TRACE] TRACE COVERAGE - Modulo Clientes (Microfase 12)")
  Linha 250:     generate_coverage_report(tracer)
  Linha 260:     # Retorna exit code do pytest (n√£o levanta SystemExit)

[tools\trace_coverage_clientes_v2.py]
  Linha 3: Trace Coverage - M√≥dulo Clientes (Microfase 12) - V2
  Linha 18: TEST_PATH = "tests/modules/clientes/"
  Linha 19: COVERAGE_DIR = PROJECT_ROOT / "coverage" / "trace"
  Linha 35:     print("üî¨ TRACE COVERAGE - M√≥dulo Clientes (Microfase 12) V2")
  Linha 43:     # Cria diret√≥rio de coverage se n√£o existir
  Linha 44:     COVERAGE_DIR.mkdir(parents=True, exist_ok=True)
  Linha 46:     print(f"üìÅ Diret√≥rio de coverage: {COVERAGE_DIR.relative_to(PROJECT_ROOT)}")
  Linha 81:     """Executa pytest com trace ativo.
  Linha 87:         Exit code do pytest (0 = sucesso, >0 = falhas).
  Linha 90:         import pytest
  Linha 92:         print("‚ùå pytest n√£o encontrado. Instale com: pip install pytest")
  Linha 99:     # Executa pytest programaticamente
  Linha 100:     # Nota: pytest.main() retorna exit code (n√£o levanta SystemExit)
  Linha 102:         pytest.main,
  Linha 119: def generate_coverage_report_safe(tracer: trace_module.Trace) -> None:
  Linha 143:     # Escreve relat√≥rios anotados em coverage/trace/
  Linha 150:             coverdir=str(COVERAGE_DIR),
  Linha 159:     print(f"üìÅ Relat√≥rios salvos em: {COVERAGE_DIR.relative_to(PROJECT_ROOT)}")
  Linha 173:     cover_files = sorted(COVERAGE_DIR.glob("**/*.cover"))
  Linha 180:         # Mostra apenas caminho relativo ao COVERAGE_DIR
  Linha 181:         rel = file.relative_to(COVERAGE_DIR)
  Linha 193:     print("‚ú® Coverage trace conclu√≠do!")
  Linha 196:     print("   1. Examine arquivos .cover em coverage/trace/")
  Linha 211:     generate_coverage_report_safe(tracer)

[tools\verify_app_clientes_coverage_env.py]
  Linha 10: 4. Diagn√≥stico de inclus√£o/exclus√£o de tests/modules
  Linha 11: 5. Coleta real do pytest (--collect-only)
  Linha 15:     python tools/verify_app_clientes_coverage_env.py
  Linha 268: def scan_coverage_commands() -> List[Tuple[str, int, str]]:
  Linha 270:     Varre arquivos conhecidos procurando comandos pytest/coverage.
  Linha 285:         "pytest.ini",
  Linha 286:         "pytest_cov.ini",
  Linha 287:         ".coveragerc",
  Linha 298:         "pytest",
  Linha 299:         "--cov",
  Linha 300:         "pytest-cov",
  Linha 301:         "coverage",
  Linha 302:         "tests/unit",
  Linha 303:         "tests/modules",
  Linha 323: def diagnose_coverage_commands(diag_dir: pathlib.Path) -> None:
  Linha 324:     """Gera 03_app_coverage_commands_found.txt."""
  Linha 331:     results = scan_coverage_commands()
  Linha 354:     write_diagnostic("03_app_coverage_commands_found.txt", "\n".join(lines), diag_dir)
  Linha 359:     Analisa se comandos/configs incluem ou excluem tests/modules.
  Linha 367:         "pytest_ini_testpaths": None,
  Linha 368:         "pytest_ini_norecursedirs": None,
  Linha 373:     results = scan_coverage_commands()
  Linha 376:         if "verify_app_clientes_coverage_env.py" in filepath:
  Linha 380:         if "tests/unit" in line_content and "tests/modules" not in line_content:
  Linha 382:             if "pytest" in line_content.lower():
  Linha 389:     # Analisar pytest.ini
  Linha 390:     for ini_file in ["pytest.ini", "pytest_cov.ini"]:
  Linha 399:                         analysis["pytest_ini_testpaths"] = match.group(1).strip()
  Linha 404:                         analysis["pytest_ini_norecursedirs"] = match.group(1).strip()
  Linha 410:         analysis["conclusion"] = "EXCLUI tests/modules"
  Linha 411:     elif analysis["pytest_ini_testpaths"] and "tests" in analysis["pytest_ini_testpaths"]:
  Linha 412:         analysis["conclusion"] = "INCLUI tests/modules (testpaths=tests)"
  Linha 429:     lines.append("[Comandos que especificam APENAS tests/unit]")
  Linha 445:     lines.append("[Configura√ß√£o pytest.ini / pytest_cov.ini]")
  Linha 446:     if analysis["pytest_ini_testpaths"]:
  Linha 447:         lines.append(f"  testpaths: {analysis['pytest_ini_testpaths']}")
  Linha 448:         if "tests" in analysis["pytest_ini_testpaths"] and "tests/unit" not in analysis["pytest_ini_testpaths"]:
  Linha 453:     if analysis["pytest_ini_norecursedirs"]:
  Linha 454:         lines.append(f"  norecursedirs: {analysis['pytest_ini_norecursedirs']}")
  Linha 461:     if analysis["conclusion"] == "EXCLUI tests/modules":
  Linha 463:         lines.append("  - Comandos encontrados excluem tests/modules/clientes")
  Linha 465:     elif analysis["conclusion"] == "INCLUI tests/modules (testpaths=tests)":
  Linha 467:         lines.append("  - Configura√ß√£o inclui tests/modules/clientes")
  Linha 476: def run_pytest_collect_only(diag_dir: pathlib.Path) -> None:
  Linha 477:     """Gera 05_pytest_collect_only_active_command.txt."""
  Linha 480:     lines.append("DIAGN√ìSTICO 05: PYTEST COLLECT-ONLY (COLETA REAL)")
  Linha 491:     # Executar pytest --collect-only -q
  Linha 494:             [str(python_exe), "-m", "pytest", "--collect-only", "-q"],
  Linha 501:         lines.append("[Sa√≠da do comando: pytest --collect-only -q]")
  Linha 516:         if "tests/modules/clientes" in result.stdout:
  Linha 517:             lines.append("‚úì tests/modules/clientes DETECTADO na coleta")
  Linha 520:             count = result.stdout.count("tests/modules/clientes")
  Linha 523:             lines.append("‚úó tests/modules/clientes N√ÉO DETECTADO na coleta")
  Linha 525:             lines.append("  - Comando exclui tests/modules")
  Linha 527:             lines.append("  - Configura√ß√£o pytest.ini exclui o diret√≥rio")
  Linha 533:         lines.append(f"‚úó ERRO ao executar pytest: {e}")
  Linha 540:     write_diagnostic("05_pytest_collect_only_active_command.txt", "\n".join(lines), diag_dir)
  Linha 552:     # 1) HAS_CUSTOMTKINTER redefinido em tests/modules/clientes
  Linha 554:     for pattern in ["tests/modules/clientes/**/*.py", "tests/unit/modules/clientes/**/*.py"]:
  Linha 597:         if filepath.name == "verify_app_clientes_coverage_env.py":
  Linha 628:         lines.append("  1. HAS_CUSTOMTKINTER redefinido em tests/modules/clientes/**/*.py")
  Linha 677:     diagnose_coverage_commands(diag_dir)
  Linha 679:     run_pytest_collect_only(diag_dir)
  Linha 690:     print("  docs/CLIENTES_MICROFASE_18_VERIFY_APP_ENV_AND_COVERAGE.md")

================================================================================